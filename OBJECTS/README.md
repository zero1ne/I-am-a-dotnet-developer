## 내가 알았던 객체지향 이란
- 객체 간의 상호작용을 통해 작동하는 프로그램을 만드는 Paradigm
- 잘 만들어진 객체지향이란 → 객체간의 책임이 뚜렷하고, 경계가 명확하며, 일관성 있는 의존성을 가져야한다.

#### 성질
- Abstraction : 객체에서 행위(Method)와 속성(Property)를 추출하는 것
- Encapsulation : 객체에 변수와 함수를 묶는 것
- Inheritance : 부모 객체의 속성을 자식에게 물려 주는 것
- Polymorphism : 같은 이름이지만 다른 행동을 하는 것 → Overriding / Overloading

#### Q/A
Q. Overriding / Overloading 시에 Return 값은 어떻게 되어야하는가?  
A. Overriding 시에는 무조건 같아야 하고, Overloading 시에는 다를 수도 있다. Calculator의 Add(int, int) -> int 를 생각해보면 쉽게 이해할 수 있을 듯

#### 잘 설계하기 위해서는 → SOILD
- Single Responsibility : 객체는 단 한가지일만 수행하여야 한다
- Open-Closed : 인터페이스 등을 사용하여 기존의 코드를 변경하지 않으면서 추가할 수 있도록 하여야 한다.
- Liskov Substituition : 자식은 부모가 하는 행동을 수행할 수 있어야 한다.
- Interface Segregation : 인터페이스는 작고 구체적이야 한다.
- Dependency Inversion : 객체간의 의존관계는 원칙을 가지고 있어야 한다.

## Objects : 코드로 이해하는 객체지향 설계

### 1장 : 객체, 설계
1. 티켓 판매 애플리케이션
#### Requirement
- 관람객은 초대장/현금/티켓을 가지고 있는 가방을 가지고 있다
- 매표소에서 초대장을 티켓으로 교환하거나 구매한다. → 티켓과 티켓의 판매금액을 보관한다.
- 판매원은 초대장을 티켓으로 교환하거나 돈을 받고 티켓을 판매한다.

#### Code
- 작성 시간이 너무 많이 걸림(약 4시간) - 코드를 많이 작성해 보지 않아서 그렇지 않을까?

2. 무엇이 문제인가 / ...
- 잘 작동하고, 변경이 용이해야 하며, 이해하기 쉬운 코드가 만들어져야 한다.
- 변경에 취약한 이유 → 객체 사이에 불필요한 의존성(Dependency)이 있는 것, 결합도(Coupling)를 낮추어야 한다
- 객체의 자율성을 높여야 한다 → 객체가 자신을 스스로 책임 질 수 있도록 캡슐화를 적용한다.
- 현실에서 수동적일지라도 객체 지향에서는 모든 객체가 능동적이여야 한다. → 의인화(anthropomorphism)
- 설계는 항상 **Trade-Off** 라는 것을 명심하자.

### 2장 : 객체지향 프로그래밍
1. 영화 예매 시스템
#### Requirement
- 영화는 영화에 대한 기본 정보(제목, 상영시간, 가격정보, etc)를 가지고 있다. 
- 상영은 실제로 관객들이 영화를 관람하는 사건을 표현한다.
- 할인 조건은 가격의 할인 여부를 결정하며, 순서 조건과 기간 조건의 두 종류로 나눌 수 있다 → 여러개의 조건을 적용할 수 있음(OR)
- 할인 정책은 가격의 할인 요금을 결정하며, 금액 할인 정책과 비율 할인 정책이 있다 → 영화별로 하나의 할인 정책만 가능
- 예매완료시 제목, 상영정보, 인원, 정가, 결제 금액을 포함한 예매 정보를 생성

#### Code
- 유연성이 떨어지는 것처럼 느껴짐 

2. 객체 지향 프로그래밍을 향해 / ...
- 도메인을 구성하는 개념과 관계를 표현 → 할인 정책이 있는 경우에만 조건이 있다는 것을 파악할 수 있다
- 객체간의 상호작용을 위해 메시지를 전송하고 수신하는 부분이 필요
- **Template Pattern** : 부모클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 것 
- 코드의 의존성과 실행 시점의 의존성이 다를 수 있다 → 코드가 유연성이 높아지지만 이해하기 어려워진다.
- 차이에 의한 프로그래밍 : 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법
- **Polymorphism** : 동일한 메세지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력(실제 어떤 메소드가 실행되는가)
- 상속 → 캡슐화를 위반하고 설계를 유연하지 못하게 할 수 있다, 합성 → 메시지를 통해 느슨하게 연결되므로 조금 더 선호됨

### 3장 : 역할, 책임, 협력
1. 협력
- 협력 : 객체가 기능을 구현하기 위해 수행하는 상호작용
- 메시지 전송을 통해 다른 객체와 커뮤니케이션 → 객체의 행동을 결정
- 객체를 설계하는 데 필요한 문맥(context)를 제공해 줌

2. 책임
- 책임 : 객체에 의해 정의되는 응집도 있는 행위의 집합
- '하는 것'과 '아는 것' → 객체에 책임을 할당하기 위한 가장 기본적인 원칙
- **Information Expert Pattern** : 책임을 수행하는데 필요한 정보를 가장 잘 알고 있는 전문가에게 책임을 할당하는 것 → Responsibility Driven Design 
- 메시지가 객체를 결정 : 객체가 최소한의 인터페이스(mininal interface), 충분히 추상적인 인터페이스(abstract interface)를 가지게 됨
- 행동이 상태를 결정 : 협력이 행동을 결정하고 행동이 상태를 결정한다 → Data Drivien Design

3. 역할
- 역할 : 객체가 특정한 협력 안에서 수행하는 책임의 집합
- 유연하고 재사용 가능한 협력 → Abstraction

### 4장 : 설계 품질과 트레이드 오프
1. 데이터 중심의 영화 예매 시스템 / ...
- 데이터(상태)에 초점을 맞추는 설계는 변경에 취약하다
- **Encapsulation** : 변경될 수 있는 어떤 것(구현)이라도 캡슐화 하여야 한다.
- **Cohesion** : 모듈의 내부 요소들이 연관되어 있는 정도 → 객체에 얼마나 관련 높은 책임(**SRP**)을 할당했는가?
- 변경의 관점에서 : 변경이 발생할때 모듈 내부에서 발생하는 변경의 정도
- **Coupling** : 의존성의 정도 → 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는가?
- 변경의 관점에서 : 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도 → **인터페이스**에 의존하게 하여야 낮은 결합도를 얻을 수 있다.
- 데이터 중심의 설계는 너무 이른 시기에 데이터에 대해 결정하며, 객체를 고립시킨채 오퍼레이션을 결정 → 본질적으로 캡슐화 위반, 낮은 응집도, 높은 결합도가 발생하기 쉽다.

### 5장 : 책임 할당하기
1. 책임 주도 설계를 향해
- 데이터보다 행동을 먼저 결정하라
- 협력이라는 문맥 안에서 책임을 결정하라 : 메시지를 전송해야 하는 데 누구에게 전송하지?

2. 책임 할당을 위한 GRASP(General Reqsponsibility Assignment Software Pattern) Pattern
- 3.2. Information Expert Pattern : 정보 전문가에게 책임을 할당하라
- **Low Coupling Pattern** / **High Cohesion Pattern** : 낮은 결합도, 높은 응집도의 설계
- **Creator Pattern** : 생성될 객체에 대해 잘 알거나 사용해야하는 객체, 즉 결합된 객체에 인스턴스를 생성할 책임을 할당

3. 구현을 통한 검증
- 인스턴스 변수가 함께 초기화 되는 속성을 기준으로 코드를 분리해야 한다.
- 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다.
- **Polymorphism Pattern** : 객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 타입의 책임으로 할당한다.
- **Protected Variations Pattern** : 변하지 않는 인터페이스 뒤로 변경을 캡슐화 한다.

4. 책임 주도 설계의 대안
- 책임을 어디에 두어야하는지 결정하기 어렵다 → Refactoring 을 통해 해결할 수 있다.
- 메서드를 응집도 있는 수준으로 분해 → 객체를 자율적으로 만들기 위해 메서드를 적절한 위치(일반적으로는 인자에 정의된 클래스 중 하나)로 이동한다.

### 6장 : 메시지와 인터페이스
1. 협력과 메시지
- 메시지 전송 : 오퍼레이션명(Operation name), 인자(argument), 메시지 수신자(Receiver)로 구성 → 객체들이 협력하기 위한 유일한 의사소통 수단
- 메서드 : 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저
- 퍼블릭 인터페이스 : 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합
- 오퍼레이션 : 퍼블릭 인터페이스에 포함된 메시지
- 시그니처 : 오퍼레이션이나 메서드의 이름과 파라미터 목록

2. 인터페이스와 설계 품질 / ...
- 디미터 법칙 : 객체의 내부 구조에 강하게 결합되지 않도록 협력경로를 제한하라 → 여러개의 도트를 사용한 코드가 객체의 내부 구조를 노출하는가?
- 묻지말고 시켜라 : 밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들어라 → 응집도와 결합도에 따라 때로는 물어보아라
- 명령-쿼리 분리(Command-Query Seperation) 원칙 → 객체 지향에서는 부수효과를 기반으로 한다. 
  - 객체의 상태를 변경하는 명령(프로시저)는 반환값을 가질 수 없다.
  - 객체의 정보를 반환하는 쿼리(함수)는 상태를 변경할 수 없다.
- 의도를 드러내는 인터페이스

### 7장 : 객체 분해
1. ... / 프로시저 추상화와 기능 분해
- 프로시저 추상화 → 기능 분해(Functional Decompostion) : 하향식 접근법(Top-Down Approach)
- 하나의 메인 함수라는 비현실적인 아이디어 : 하나의 알고리즘이나 배치 처리를 구현하기에는 적합
- 메인 함수의 빈번한 재설계 / 비즈니스 로직과 사용자 인터페이스의 결합 
- 성급하게 결정된 실행 순서 : 다른 함수와 시간적으로 강하게 결합되어있다 → 높은 결합도
- 데이터 변경으로 인한 파급효과 : 변경에 대한 영향을 최소화하기 위해 영향을 받는 부분과 아닌 부분을 분리해야한다 → 정보 은닉과 모듈의 필요성

2. 모듈
- 정보 은닉(Information Hiding) : 모듈은 데이터와 함수가 통합된 한차원 높은 추상화를 제공할 수 있음 → 인스턴스의 개념 부재
  - 복잡성 : 외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공하여 복잡도를 낮춤
  - 변경 기능성 : 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공

3. 데이터 추상화와 추상 데이터 타입
- 데이터 추상화 → 타입 추상화(Type Abstraction) : 추상 데이터 타입(Abstract Data Type)
- 타입 정의 선언 / 인스턴스를 다루기 위한 오퍼레이션의 집합 / 오퍼레이션을 통해서만 조작할 수 있도록 데이터 보호 / 여러개의 인스턴스 생성 가능

4. 클래스
- 객체 기반 프로그래밍(Object-Based Programming) : 상속과 다형성이 존재하지 않음
- 데이터 추상화 → 프로시저 추상화(Procedure Abstraction) : 객체지향(Object-Oriented)
- 객체 지향은 타입을 기준으로 오퍼레이션을 묶는다 → 절차 추상화(Procedural Abstraction)
- 타입 변수를 이용한 조건문을 다형성으로 대체 → 기존 코드에 영향을 미치지 않고 새로운 객체 유형과 행위를 추가 : **개방-폐쇄 원칙(Open-Closed Principle)**
- 타입 추가가 빈번하다면 객체 지향을, 오퍼레이션 추가가 빈번하다면 추상 데이터 타입을 사용하라

### 8장 : 의존성 관리하기
1. 의존성 이해하기
- 직접 의존성(Direct Dependency) / 간접 의존성(Indirect Dependency)
- 런타임 의존성(Run-time Dependency) / 컴파일타임 의존성(Compile-time Dependency) : 컴파일타임 구조와 런타임 구조가 거리가 멀수록 설계가 유연해지고 재사용 가능해진다.

2. 유연한 설계
- 느슨한 결합도(Loose coupling) : 다양한 환경에서 재사용할 수 있게 만들어주는 바람직한 의존성
- 추상화에 의존 → 의존하는 대상이 더 추상적일수록 결합도는 낮아진다
- 명시적인 의존성(Explicit Dependency) : Setter / 메서드 인자를 사용하는 방식으로 의존성이 퍼블릭 인터페이스에 노출

### 9장 : 유연한 설계
1. 개방-폐쇄 원칙(Open-Closed Principle)
- 확장에 대해 열려 있다 : 요구 사항이 변경될 때 변경에 맞게 새로운 **동작**을 추가하여 기능을 확장
- 수정에 대해 닫혀 있다 : 기존의 **코드**를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다
- 추상화는 확장을 가능하게 하고 추상화에 대한 의존은 폐쇄를 가능하게 한다

2. 생성 사용 분리
- 객체를 제작하고 의존성을 연결하는 시작 단계와 실행 단계를 분리해야 한다.
- **Factory Pattern** : 객체 생성만을 전담하는 객체로 이를 통해 생성의 책임을 분리 할 수 있다.
- 표현적 분해(Representational Decomposition) : 도메인 모델을 표현하는 객체에게 책임을 할당 → 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 문제를 피할 수 없을때도 존재한다
- 행위적 분해(Behavioral Decompostion) : 가공의 객체를 추가해서 책임을 할당 → Pure Fabrication(순수한 가공물)

3. 의존성 주입(Dependency Injection)
- 생성자 주입(Constructor) : 객체를 생성하는 시점에 생성자를 통한 의존성 해결
- setter 주입(Setter) Injection) : 객체 생성 후 setter 메서드를 통한 의존성 해결 → 객체가 비정상적인 상태로 생성될 수 있다
- 메서드 주입(Method) : 메서드 실행시 인자를 이용한 의존성 해결 
- Service Locator Pattern : 의존성을 숨기기 때문에 캡슐화를 위반한다 → Anti-Pattern

4. 의존성 역전 원칙(Dependency Inversion Principle)
- 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다 → 추상화(추상클래스, 인터페이스)에 의존해야 한다. 
- 추상화는 구체적인 사항에 의존해서는 안된다 → 구체 클래스는 의존성의 시작점이여야 한다.
- Seperated Interface Pattern : 함께 재사용될 필요가 없는 클래스들은 별도의 독립적인 패키지에 모아야한다.

5. 유연성에 대한 조언
- 유연성은 복잡성을 수반하기 때문에 수용할 가치가 있을때만 가치가 있다
- 역할, 책임, 협력에 집중하라

## 10장 : 상속과 코드 재사용
1. 상속과 중복 코드 / ...
- 코드를 재사용하기 위해 새로운 코드를 추가한다.
- DRY(Don't Repeat Yourself) 원칙 : 코드 안에 중복이 있어서는 안된다.
- 취약한 기반 클래스 문제(Fragile Base Class Problem) : 자식 클래스가 부모 클래스의 변경에 취약해지는 현상
- 자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출 → 강하게 결합되므로 제거 방법을 찾아야 한다.
- 부모 클래스에서 상속받은 메서드 → 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.
- 자식 클래스가 부모 클래스의 메서드를 오버라이딩 → 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.
- 클래스를 상속받으면 높은 결합도, 낮은 캡슐화가 발생 → 자식 클래스와 부모 클래스를 무조건 동시에 변경해야 한다.

2. ... / 차이에 의한 프로그래밍
- 추상화에 의존하면 상속으로 인한 피해를 최소화 할 수 있다 → 차이를 메서드로 추출하라 / 중복 코드를 부모 클래스로 올려라 
- 상속으로 인한 클래스 사이의 결합을 피할 수는 없다 → 행동을 변경하기 위해 인스턴스 변수를 추가하더라도 상속 계층 전체에 부작용이 퍼지지 않게 막고 싶다.

## 11장 : 합성과 유연한 설계
1. 상속을 합성으로 변경하기 / ...
- 상속은 is-a, 합성은 has-a 관계이다.
- 상속은 클래스 사이의 정적인 관계이고, 합성은 객체 사이의 동적인 관계이다 → 코드 재사용 면에서 유리하다
- Hook Method : 추상 메서드와 동일하게 자식 클래스에서 오버라이딩할 의도지만 기본 구현을 제공하는 메서드

2. 믹스인(mixin) 
- 객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법 → 컴파일 시점에 코드 조각을 조합
- 쌓을 수 있는 변경(stackable modification) : 클래스에 대한 변경이나 확장을 필요한 시점에 차례대로 추가

## 12장 : 다형성
1. 다형성
- Overloading(오버로딩) : 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우
- Coercion(강제) : 타입 변환을 통해 동일한 연산자를 다양한 타입에 사용
- Parametric(매개변수) : Generic 처럼 매개변수 타입을 임의로 선언한 후 사용하는 시점에 구체적인 타입으로 지정
- Inclusion(포함) : Subtype 다형성이라고도 하며, 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라짐
- 상속은 클라이언트 관점에서 인스턴스를 동일하게 행동하는 그룹으로 묶기 위함이여야 한다.

2. 상속의 양면성 / ...
- Method Overriding : 자식 클래스에서 상속받은 메서드와 동일한 시그니처의 매서드를 재정의
- Method Overloading : 이름은 동일하지만 시그니처는 다른 메서드를 자식 클래스에 추가
- 데이터 관점의 상속 : 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스 변수를 포함
- 행동 관점의 상속 : 부모 클래스의 퍼블릭 인터페이스가 자식 클래스에 합쳐짐
- Upcasting : 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당 → 자식 클래스는 제약 없이 부모 클래스를 대체가능
- Downcasting : 부모 클래스의 인스턴스를 자식 클래스 타입으로 명시적으로 변환
- Static Binding : 코드를 작성하는 시점(static, compile-time)에 호출된 코드가 결정
- Dynamic Binding : 런타임(late)에 실행될 메서드가 결정
- Self reference : 객체가 메시지를 수신하면 self가 가리키는 객체의 클래스에서 시작해서 메서드를 탐색
- Super reference : 부모 클래스에게 메시지를 전송하기 위해 사용
- Delegation(위임) : 자신이 수신한 메시지를 다른 객체에게 동일하게 전달하여 처리를 요청 → 상속과 메커니즘을 공유

## 13장 : 서브클래싱과 서브 타이핑
1. 타입 / ...
- 동일한 퍼블릭 인터페이스를 제공하는 객체는 동일한 타입으로 분류된다.
- 서브 타입은 슈퍼 타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정리 → 슈퍼타입의 인스턴스로 간주될 수 있다.
- 행동 호환성 : 클라이언트의 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야 한다 → 대체 가능성(Substitutability)
- 인터페이스 분리 원칙(Interface Segregation) : 클라이언트의 기대에 따라 인터페이스를 분리함으로서 변경에 의해 영향을 제어하는 설계 원칙
- 서브클래싱(Subclassing) : 코드를 재사용하기 위해 상속을 사용, 행동 호환성이 없으므로 자식 클래스가 부모 클래스 대체 불가능 → 구현 상속(Implement), 클래스 상속(Class)
- 서브타이핑(Subtyping) : 타입 계층을 사용하기 위해 상속을 사용, 행동 호환성이 있으므로 자식 클래스가 부모 클래스 대체 가능 → 인터페이스 상속(Interface)
- 리스코프 치환 원칙(Liskov Substituition) : 서브타입은 기반 타입에 대해 대체 가능해야 한다 → 클라이언트와 슈퍼타입 간에 체결된 계약을 준수해야 한다.
- 계약에 의한 설계(Design By Contract) : 클라이언트가 정상적으로 메서드를 실행하기 위해 만족 시켜야하는 사전 조건(Precondition), 메서드가 실행된 후에 서버가 클라이언트에게 보장해야 하는 사후 조건(Postcondition), 메서드 실행 전후에 인스턴스가 만족시켜야 하는 클래스 불변식(Class Invariant)
- 즉, 서브타입에는 슈퍼타입보다 같거나 약한 사전 조건만 정의할 수 있고, 같거나 강한 사후 조건만 정의 할 수 있다.

## 14장 : 일관성 있는 협력
1. ... / 설계에 일관성 부여하기 / ...
- 데이터 캡슐화 : 인스턴스 변수의 가시성을 통해 클래스의 내부 데이터를 캡슐화
- 메서드 캡슐화 : 인스턴스 메서드의 가시성을 통해 클래스의 내부 행동을 캡슐화
- 객체 캡슐화 : 객체의 인스턴스 변수를 포함한다면 해당 객체 사이의 관계를 캡슐화 → 합성
- 서브타입 캡슐화 : 기반 클래스와의 추상 클래스가 서브타입의 종류를 캡슐화 → 다형성의 기본
- 변하는 개념을 변하지 않는 개념으로부터 분리 : 변하는 부분의 공통적인 행동을 추상 클래스나 인터페이스로 추상화 → 변하는 부분은 변하지 않는 부분의 서브타입이 됨
- 변하는 개념을 캡슐화 : 타입 계층을 변하지 않는 부분에 합성
- 협력 패턴 : 유사한 개념에 대해 유사한 협력 패턴을 적용하라 → 개념적 무결성(Conceptual Integrity)를 유지할 수 있다.

## 15장 : 디자인 패턴과 프레임워크
1. 디자인 패턴과 설계 재사용 / ...
- 아키텍처 패턴(Architecture) : 서브시스템들의 책임을 정의하고 관계를 조직화하는 규칙과 가이드 라인 제공 → 소프트웨어들의 전체적인 구조를 결정
- 분석 패턴(Analysis) : 모델링 시에 발견되는 공통적인 구조를 표현하는 개념들의 집합
- 디자인 패턴(Design) : 일반적인 설계 문제를 해결하며 협럭하는 컴포넌트 사이에서 반복적으로 발생하는 구조를 서술 → 클래스가 아닌 역할이 구성요소
- 이디엄(Idiom) : 특정 프로그래밍 언어에 종속적으로, 주어진 언어의 기능을 사용해 특정 측면을 구현
- 패턴을 가장 효과적으로 적용하는 방법은 패턴을 지향하거나 패턴을 목표로 리팩토링하는 것 → 정당한 이유없이 맹목적으로 사용시 설계를 복잡하게 함
- 프레임 워크 : 추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템을 구현해 놓은 재사용 가능한 설계
- 제어 역전 원리(Inversion of Control) : 의존성을 역전시키면 제어의 주체가 역전된다 → 프레임워크가 제어 흐름을 가져간다

## 부록 A : 게약에 의한 설계
1. 협력과 계약 / ...
- 사전 조건(Precondition) : 메서드가 호출되기 위해 만족되야 하는 조건 → 메서드의 요구사항, 클라이언트의 의무
- 사후 조건(Postcondition) : 메서드가 실행된 후에 서버가 클라이언트에게 보장해야 하는 조건 → 서버의 의무
- 불변식(Class Invariant) : 메서드 실행 전후에 항상 참이라고 보장되는 서버의 조건
- 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 계약을 준수해야 한다.
- 계약 규칙(Contract rules) : 서브타입에는 슈퍼타입보다 같거나 약한 사전 조건만 정의할 수 있고, 같거나 강한 사후 조건만 정의 할 수 있으며, 슈퍼타입의 불변식을 유지해야 한다.
- 가변성 규칙(Variance rules) : 서브타입의 메서드 파라미터는 반공변성을 지녀야 하고, 리턴 타입은 공변성을 가져야 하며, 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안된다.
- 공변성(Covariance) : 해당 위치에서 서브타입이 슈퍼타입 대신 사용될 수 있다.
- 반공변성(Contravariance) : 해당 위치에서 슈퍼타입이 서브타입 대신 사용될 수 있다.
- 문제가 발생한 위치에서 예외를 바로 던지는 것이 문제의 원인을 파악할 수 있는 가장 빠른 방법이다.

## 부록 B : 타입 계층의 구현
- 타입 : 동일한 퍼블릭 인터페이스를 가진 객체들의 범주 → 클래스는 구현 메커니즘이므로 클래스가 아니라 타입을 강조하라
- 클래스 : 객체의 타입과 구현을 동시에 정의 하는 것 → 사용자 정의 타입(User-Defined Data Type)
- 인터페이스 : 여러 클래스가 동일한 타입, 한 클래스가 여러 타입을 구현할 수 있다.
- 인터페이스를 통해 타입을 정의하고 추상 클래스를 통해 코드 중복을 방지 → 골격 구현 추상 클래스(Skeletal Implementation Abstract Class)
- 덕 타이핑 : 클래스나 인터페이스에 대한 의존성을 메시지에 대한 의존성으로 대체 → 풍부한 컨텍스트 독립성(Context Independnece) 제공
- 믹스인(Mixin) : 객체를 생성할 때 코드 일부를 섞어 넣을 수 있도록 만들어진 추상 서브클래스

## 부록 C : 동적인 협력, 정적인 코드
- 정적 모델(Static Model) : 프로그램 코드의 구조를 담는 모델 → 타입과 관계로 구성
- 동적 모델(Dynamic Model) : 프로그램 실행 구조를 표현하는 모델 → 객체와 협력으로 구성
- 동적 모델을 기반으로 정적 모델을 구상할때는 단순하고, 결합도가 낮으며 중복 코드가 없는 변경을 수용할 수 있는 코드를 만들어야 한다
- 도메인 모델 : 사용자가 프로그램을 사용하는 대상 영역에 대한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태 → 최종적으로는 객체의 행동과 변경에 기반해야 하며 코드의 구조를 반영하여야 한다.
- Type Object Pattern : 어떤 인스턴스가 다른 인스턴스의 타이을 표현 하는 방법 
- 분석 모델 : 문제 도메인을 설명하는 모델 → 기술적인 해결 방법을 언급해서는 안됨
- 설계 모델 : 분석 모델을 바탕으로 기술적인 관점에서 솔루션을 서술
- 구현 모델 : 설계 모델을 기반으로 코드로 변경
- 객체 지향에서 도메인의 개념과 객체 사이의 협력을 고민하면 분석, 설계, 구현에 대해 동시에 고민하는 것이 된다 → 항상 행동과 변경에 초점을 두어라
